// Generated by CoffeeScript 1.9.1
(function() {
  var app, collect_monitoring, collect_quantiles, collect_stats, collect_subtree,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  app = angular.module("ng-tank-report", ["angular-rickshaw"]);

  collect_subtree = function(storage, subtree, ts) {
    var key, node, results;
    results = [];
    for (key in subtree) {
      node = subtree[key];
      if (typeof node === 'number' || typeof node === 'array') {
        results.push(storage[key].push({
          x: ts,
          y: node
        }));
      } else {
        results.push(collect_subtree(storage[key], node, ts));
      }
    }
    return results;
  };

  collect_stats = function(stats) {
    var j, len, metric, ref, result, statItem, value;
    result = {};
    for (j = 0, len = stats.length; j < len; j++) {
      statItem = stats[j];
      ref = statItem.metrics;
      for (metric in ref) {
        value = ref[metric];
        if (!result[metric]) {
          result[metric] = [];
        }
        result[metric].push({
          x: +statItem.ts,
          y: +value
        });
      }
    }
    return result;
  };

  collect_monitoring = function(monitoring) {
    var host, hostData, j, len, metric, monItem, ref, ref1, result, subgroup, value;
    result = {};
    for (j = 0, len = monitoring.length; j < len; j++) {
      monItem = monitoring[j];
      ref = monItem.data;
      for (host in ref) {
        hostData = ref[host];
        if (!result[host]) {
          result[host] = {
            comment: hostData.comment,
            metrics: {}
          };
        }
        ref1 = hostData.metrics;
        for (metric in ref1) {
          value = ref1[metric];
          subgroup = metric.split("_", 1);
          if (!result[host].metrics[subgroup]) {
            result[host].metrics[subgroup] = {};
          }
          if (!result[host].metrics[subgroup][metric]) {
            result[host].metrics[subgroup][metric] = [];
          }
          result[host].metrics[subgroup][metric].push({
            x: +monItem.timestamp,
            y: +value
          });
        }
      }
    }
    return result;
  };

  collect_quantiles = function(data) {
    var dataItem, i, j, k, l, len, ref, ref1, ref2, result, tag, tagData;
    result = {
      overall: {
        interval_real: {
          q: {}
        }
      },
      tagged: {}
    };
    for (j = 0, len = data.length; j < len; j++) {
      dataItem = data[j];
      for (i = k = 0, ref = dataItem.overall.interval_real.q.q.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        if (!result.overall.interval_real.q[dataItem.overall.interval_real.q.q[i]]) {
          result.overall.interval_real.q[dataItem.overall.interval_real.q.q[i]] = [];
        }
        result.overall.interval_real.q[dataItem.overall.interval_real.q.q[i]].push({
          x: dataItem.ts,
          y: dataItem.overall.interval_real.q.value[i]
        });
      }
      ref1 = dataItem.tagged;
      for (tag in ref1) {
        tagData = ref1[tag];
        if (!result.tagged[tag]) {
          result.tagged[tag] = {
            interval_real: {
              q: {}
            }
          };
        }
        for (i = l = 0, ref2 = tagData.interval_real.q.q.length; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
          if (!result.tagged[tag].interval_real.q[tagData.interval_real.q.q[i]]) {
            result.tagged[tag].interval_real.q[tagData.interval_real.q.q[i]] = [];
          }
          result.tagged[tag].interval_real.q[tagData.interval_real.q.q[i]].push({
            x: dataItem.ts,
            y: tagData.interval_real.q.value[i]
          });
        }
      }
    }
    return result;
  };

  app.controller("TankReport", function($scope, $element) {
    $scope.status = "Disconnected";
    $scope.data = document.cached_data.data;
    $scope.uuid = document.cached_data.uuid;
    $scope.updateData = function(tankData) {
      var data, storage, storages, ts;
      for (ts in tankData) {
        storages = tankData[ts];
        for (storage in storages) {
          data = storages[storage];
          collect_subtree($scope.data[storage], data, +ts);
        }
      }
      return $scope.$broadcast('DataUpdated');
    };
    $scope.buildSeries = function() {
      var areaGraphs, cache, data, hostData, hostname, metric, metrics, monitoringData, name, overallData, quantilesData, series, statsData, subgroup, taggedData;
      cache = document.cached_data.data;
      if (cache.stats && cache.data && cache.monitoring) {
        overallData = {};
        taggedData = {};
        quantilesData = collect_quantiles(cache.data);
        statsData = collect_stats(cache.stats);
        monitoringData = collect_monitoring(cache.monitoring);
      } else {
        overallData = {};
        taggedData = {};
        quantilesData = {};
        statsData = {};
        monitoringData = {};
        setTimeout((function() {
          return location.reload(true);
        }), 3000);
      }
      areaGraphs = ['CPU', 'Memory'];
      $scope.monitoringGraphData = (function() {
        var results;
        results = [];
        for (hostname in monitoringData) {
          hostData = monitoringData[hostname];
          results.push({
            hostname: hostname,
            charts: (function() {
              var ref, results1;
              ref = hostData.metrics;
              results1 = [];
              for (subgroup in ref) {
                metrics = ref[subgroup];
                results1.push({
                  name: subgroup,
                  features: {
                    palette: 'spectrum14',
                    hover: {},
                    xAxis: {},
                    yAxis: {},
                    ySecondaryAxis: {
                      scale: null
                    },
                    legend: {
                      toggle: true,
                      highlight: true
                    }
                  },
                  options: {
                    renderer: 'multi'
                  },
                  series: ((function() {
                    var results2;
                    results2 = [];
                    for (metric in metrics) {
                      series = metrics[metric];
                      results2.push({
                        name: metric,
                        data: series,
                        renderer: indexOf.call(areaGraphs, subgroup) >= 0 ? "area" : "line"
                      });
                    }
                    return results2;
                  })()).concat([
                    {
                      name: "Requests per second",
                      color: "red",
                      renderer: "line",
                      data: statsData.reqps
                    }
                  ])
                });
              }
              return results1;
            })()
          });
        }
        return results;
      })();
      $scope.quantilesGraphData = {
        name: "Response time quantiles",
        features: {
          palette: 'classic9',
          hover: {},
          xAxis: {},
          yAxis: {},
          legend: {
            toggle: true,
            highlight: true
          }
        },
        options: {
          renderer: 'area',
          stack: false,
          height: $element[0].offsetHeight - 45 - 62
        },
        series: ((function() {
          var ref, results;
          ref = quantilesData.overall.interval_real.q;
          results = [];
          for (name in ref) {
            data = ref[name];
            results.push({
              name: name,
              data: data
            });
          }
          return results;
        })()).sort(function(a, b) {
          if (parseFloat(a.name) <= parseFloat(b.name)) {
            return 1;
          } else {
            return -1;
          }
        })
      };
      $scope.rps = {
        name: "Responses per second",
        features: {
          palette: 'spectrum14',
          hover: {},
          xAxis: {},
          yAxis: {},
          legend: {
            toggle: true,
            highlight: true
          }
        },
        options: {
          renderer: 'line'
        },
        series: [
          {
            name: 'RPS',
            data: overallData.RPS
          }
        ]
      };
      $scope.protoCodes = {
        name: "Protocol return codes",
        features: {
          palette: 'spectrum14',
          hover: {},
          xAxis: {},
          yAxis: {},
          legend: {
            toggle: true,
            highlight: true
          }
        },
        options: {
          renderer: 'area',
          stack: true,
          height: $element[0].offsetHeight - 45 - 62
        },
        series: ((function() {
          var ref, results;
          ref = overallData.http_codes;
          results = [];
          for (name in ref) {
            data = ref[name];
            results.push({
              name: name,
              data: data
            });
          }
          return results;
        })()).sort(function(a, b) {
          if (parseFloat(a.name) <= parseFloat(b.name)) {
            return 1;
          } else {
            return -1;
          }
        })
      };
      return $scope.netCodes = {
        name: "Network return codes",
        features: {
          palette: 'spectrum14',
          hover: {},
          xAxis: {},
          yAxis: {},
          legend: {
            toggle: true,
            highlight: true
          }
        },
        options: {
          renderer: 'area',
          stack: true,
          height: $element[0].offsetHeight - 45 - 62
        },
        series: ((function() {
          var ref, results;
          ref = overallData.net_codes;
          results = [];
          for (name in ref) {
            data = ref[name];
            results.push({
              name: name,
              data: data
            });
          }
          return results;
        })()).sort(function(a, b) {
          if (parseFloat(a.name) <= parseFloat(b.name)) {
            return 1;
          } else {
            return -1;
          }
        })
      };
    };
    return $scope.buildSeries();
  });

}).call(this);
